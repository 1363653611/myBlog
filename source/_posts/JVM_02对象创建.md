---
title: 02 JVM对象创建
date: 2019-12-09 18:14:10
tags:
	- JVM
	- java
categories:
	- JVM
	- java
topdeclare: true
reward: true
---

### 对象的创建

#### 遇到new指令后
1. 在常量池中定位到一个类的符号引用
2. 检查符号引用代表的类是否被加载、解析、初始化。如果没有，就需要执行类的加载过程
3. 为新生对象分配内存空间
<!--more-->
	- 指针碰撞 Dump the point
		- 条件：
			1. 假设java堆中的内存是绝对规整的。
			2. 所有用过的内存都放在一边，空闲的放在另一边。
			3. 中间放着一个指针作为分界点的指示器。
		- 操作：分配内存就是仅仅把那个指针向空闲那边挪动一段与对象相等的距离
		- 对应的垃圾收集器(带compact功能的收集器)
			- serial
			- parNew
	- 空闲列表  free list
		- 条件：
			1. Java堆中的内存不规整，已使用和未使用的内存相互交错
			2. 虚拟机维护一个列表，用于记录那些内存时可用的。
		- 操作：
			- 找一块足够大的空间划分给对象实例。并更新列表上的记录。
		- 对应的收集器
			- Mark-sweep
			- CMS
		- 保证线程安全的两种方式
			1. CAS配上失败重试的方式保证更新操作的原子性
			2. 把内存分配的动作按照线程划分在不同的空间之中进行（即每个线程在java堆中预先分配一块小内存--本地线程分配缓冲（TLAB））

4. 虚拟机需要将分配到的内存空间都初始化零值（不包括对象头）
	- 作用：保证了对象的实例字段在java代码中可以不赋初始值就直接使用

5. 对象头的必要设置
	- 哪个类的实例、
	- 如何才能找到类的元数据信息
	- 对象的hash码
	- GC分代年龄
	- 锁的使用情况

6. init 方法的执行
	- 对象按照程序员的意愿进行初始化

#### 内存的布局
1. 对象头 Header
	- 自身运行时数据
		- hash码
		- GC分代年龄
		- 锁的状态标志
		- 线程持有的锁
		- 偏向线程id
		- 偏向时间戳
	- 类型指针
		- 对象指向它对应元数据的指针----确定这个对象是哪个类的实例

2. 实例数据区 Instance Data

3. 对齐填充区 padding
	- 占位符的作用
4. 对象的访问定位
	- 句柄
	- 直接指针
