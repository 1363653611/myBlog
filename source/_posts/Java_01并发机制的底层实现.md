---
title: 01 java 并发机制底层实现
date: 2019-12-09 13:14:10
tags:
 - concurrency
 - 并发
 - java
categories:
 - java
 - concurrency
topdeclare: true
reward: true
---

### 基本术语
#### 上下文切换
1. 单核处理器也支持多线程执行代码.
2. cpu 通过时间分配算法来循环执行任务,当前任务执行一个时间片后会切换到一下个任务.
3. 在切换前会保存上一个任务的状态,以便于下一次切换回这个任务时,可以再加载这个任务的之前状态.
4. __定义:__ 任务从保存到再加载的过程就是一次上下文切换.
5. __注意:__ 多线程不一定比单线程快.数据量不超过百万次时,多线程比单线程反而慢.
<!--more-->
##### 如合减少上下文切换
1. 无锁并发编程
2. CAS 算法
3. 使用最少线程
4. 协程:单线程中的多任务调度,单个线程中维持多个任务切换.

#### 死锁  
避免死锁的常见的几个方法:
1. 避免一个线程同时获取多个锁
2. 避免一个线程再所内同时占用多个资源,尽量保证一个锁只占用一个资源
3. 尝试使用锁时,使用 lock.tryLock(timeOut) 来代替使用内部锁机制.
4. 对于数据库锁,己所和解锁必须再同一个数据库连接中,否则回出现解锁失败的情况.

#### 资源限制的挑战  
资源限制是指程序的执行速度受限于计算机硬件资源或者软件限制.  
##### 硬件资源限制
1. 带宽的上传/下载
2. 硬盘的读写速度
3. CPU 的处理速度

##### 软件的资源限制
1. 数据库的连接数
2. socket 的连接数

### java 并发机制的底层实现

#### volatile的应用

##### CPU 语义
1. 内存屏障(memiry Barrier)
2. 缓冲行(Cache Line)
3. 原子操作(atomic operations)
4. 缓存行填充(cache line fill)
5. 缓存命中(cache hit)
6. 写命中(write hit)
7. 写缺失(write misses the cache)

##### 增加volatile 后的作用
1. 将当前系统缓存行的数据诙谐到系统内存
2. 写的操作会使得其他CPU中缓存了该内存地址得到数据无效

#### synchronized 实现原理与应用  
java中的每种对象都可以作为锁。具体表现为：
1. 对于普通的同步方法，锁是当前对象
2. 对于静态同步方法，锁是当前类的class 对象
3. 对于同步方法块，锁是Synchronized 括号中的对象

##### java 对象头  
数组类型对象，则虚拟机用3个个字宽（word）存储对象头；  
对象为非数组类型，则使用两个字节存储对象头。  
在32位虚拟机中，1个字宽等于4个字节（32bit）。  
__对象头分解:__
1. `markWord` 32/64bit 存储对象hashCode 或锁信息
2. `Class MataData Address` 32/64bit 存储对象类型数据的指针
3. `Array length` 32/32bit 数组的长度（如果当前对象是数组）  

##### 锁的升级与对比
一共有四种锁，级别从低到高：无锁状态、偏向锁状态、轻量级锁状态 和重量级锁状态。  
锁状态会随着竞争条件主键提升。锁可以升级，但是不可以降级。
1. 偏向锁  
大多数情况下，锁不存在多线程的竞争，而是总是同一线程
多次获得。所以，为了降低获得锁的代价引入了偏向锁。

2. 轻量级锁

3. 重量级锁


#### 原子操作的实现原理

#### 小结
